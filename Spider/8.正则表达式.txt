正则表达式:正则表达式，是一种语法，用来描述你想搜索的字符串的特征。
    比如在网络爬虫当中,你想要在复杂且庞大的互联网之中匹配和寻找某信息,在单一页面规则中使用xpath或bs4固然可以,
    但在不同网站之间进行爬虫时,每个网站的设计者设计的网页元素规则不一样,则会导致我们之前的xpath或bs4规则失去效用，
    此时,我们利用正则表达式来描述出我们想寻找的某信息的字符串特征,即可在不同网站中寻找它。

常见语法:
    0.写在正则表达式里面的普通字符都是表示:直接匹配它们:
        re.search("",string)

    1.点(.)-匹配所有字符:注:一个点表示一个字符
        content = '''
                  苹果是绿色的
                  橙子是橙色的
                  香蕉是黄色的
                  乌鸦是黑色的
                  '''
        pharse = re.compile(".色")
        for i in pharse.findall(content):
	        print(i)
	2.星号(*)-重复匹配任意次:表示匹配前面的子表达式任意次,包括0次
	    比如，你要从下面的文本中，选择每行逗号后面的字符串内容，包括逗号本身。注意，这里的逗号是中文的逗号。
            苹果，是绿色的
            橙子，是橙色的
            香蕉，是黄色的
            乌鸦，是黑色的
            猴子，
        content = '''苹果，是绿色的
        橙子，是橙色的
        香蕉，是黄色的
        乌鸦，是黑色的
        猴子，'''

        import re
        p = re.compile(r'，.*')
        for one in  p.findall(content):
            print(one)
        注意:.*在正则表达式中非常常见,表示匹配任意字符任意次数.当然这个*前面不是非得是点,也可以是其它字符

    3.加号(+)重复匹配多次:+表示匹配前面的子表达式一次或多次,不包括0次。
        比如:上面的文本匹配出来不包括，

        import re
        p = re.compile(r",.+")
        for i in p.findall(content):
            print(i)

    4.问号(?)匹配0-1次:? 表示匹配前面的子表达式0次或1次
        因此"，.*?"规则匹配上述content得到的结果必为，是，是，是，

    5.花括号{}匹配指定次数:花括号表示 前面的字符匹配 指定的次数
        比如:红彤彤，绿油油，黑乎乎，绿油油油油
        表达式 油{3} 就表示匹配 连续的 油 字 3次
        表达式 油{3,4} 就表示匹配 连续的 油 字 至少3次，至多 4 次

    6.贪婪模式和非贪婪模式:
        我们要把下面的字符串中的所有html标签都提取出来，

        source = '<html><head><title>Title</title>'

        得到这样的一个列表

        ['<html>', '<head>', '<title>', '</title>']

        很容易想到使用正则表达式 <.*>

        写出如下代码

        source = '<html><head><title>Title</title>'

        import re
        p = re.compile(r'<.*>')

        print(p.findall(source))
        但是运行结果，却是

        ['<html><head><title>Title</title>']
        怎么回事？ 原来 在正则表达式中， ‘*’, ‘+’, ‘?’ 都是贪婪地，使用他们时，会尽可能多的匹配内容，

        所以， <.*> 中的 星号（表示任意次数的重复），一直匹配到了 字符串最后的 </title> 里面的e。

        解决这个问题，就需要使用非贪婪模式，也就是在星号后面加上 ? ，变成这样 <.*?>

        source = '<html><head><title>Title</title>'

        import re
        # 注意多出的问号
        p = re.compile(r'<.*?>')

        print(p.findall(source))

    7.对元字符的转义:反斜杠 \ 在正则表达式中有多种用途
        反斜杠 \ 在正则表达式中有多种用途。

        比如，我们要在下面的文本中搜索 所有点前面的字符串，也包含点本身

        苹果.是绿色的
        橙子.是橙色的
        香蕉.是黄色的
        如果，我们这样写正则表达式 .*. ， 聪明的你肯定发现不对劲。

        因为 点 是一个 元字符， 直接出现在正则表达式中，表示匹配任意的单个字符， 不能表示 . 这个字符本身的意思了。

        怎么办呢？

        如果我们要搜索的内容本身就包含元字符，就可以使用 反斜杠进行转义。

        这里我们就应用使用这样的表达式： .*\.

        content = '''苹果.是绿色的
        橙子.是橙色的
        香蕉.是黄色的'''

        import re
        p = re.compile(r'.*\.')
        for one in  p.findall(content):
            print(one)

    8.匹配某种字符类型:反斜杠后面接一些字符，表示匹配 某种类型 的一个字符
        比如:
            \d 匹配0-9之间任意一个数字字符，等价于表达式 [0-9]

            \D 匹配任意一个不是0-9之间的数字字符，等价于表达式 [^0-9]

            \s 匹配任意一个空白字符，包括 空格、tab、换行符等，等价于表达式 [\t\n\r\f\v]

            \S 匹配任意一个非空白字符，等价于表达式 [^ \t\n\r\f\v]

            \w 匹配任意一个文字字符，包括大小写字母、数字、下划线，等价于表达式 [a-zA-Z0-9_]

            缺省情况也包括 Unicode文字字符，如果指定 ASCII 码标记，则只包括ASCII字母

            \W 匹配任意一个非文字字符，等价于表达式 [^a-zA-Z0-9_]


            反斜杠也可以用在方括号里面，比如 [\s,.] 表示匹配 ： 任何空白字符， 或者逗号，或者点

    9.方括号-匹配几个字符之一:方括号表示要匹配 指定的几个字符之一
        比如:
            [abc] 可以匹配 a, b, 或者 c 里面的任意一个字符。等价于 [a-c] 。

            [a-c] 中间的 - 表示一个范围从a 到 c。

            如果你想匹配所有的小写字母，可以使用 [a-z]

            一些 元字符 在 方括号内 失去了魔法， 变得和普通字符一样了。
        比如:
            [akm.] 匹配 a k m . 里面任意一个字符

            这里 . 在括号里面不在表示 匹配任意字符了，而就是表示匹配 . 这个 字符

            如果在方括号中使用 ^ ， 表示 非 方括号里面的字符集合。

        比如:
            content = 'a1b2c3d4e5'

            import re
            p = re.compile(r'[^\d]' )
            for one in  p.findall(content):
                print(one)
            [^\d] 表示，选择非数字的字符

    10.起始、结尾位置 和 单行、多行模式:
       -:^ 表示匹配文本的 开头 位置。

        正则表达式可以设定 单行模式 和 多行模式

        如果是 单行模式 ，表示匹配 整个文本 的开头位置

        如果是 多行模式 ，表示匹配 文本每行 的开头位置

        比如，下面的文本中，每行最前面的数字表示水果的编号，最后的数字表示价格

        001-苹果价格-60，
        002-橙子价格-70,
        003-香蕉价格-80,
        如果我们要提取所有的水果编号，用这样的正则表达式 ^\d+

        上面的正则表达式，使用在Python程序里面，如下所示

        content = '''001-苹果价格-60
        002-橙子价格-70
        003-香蕉价格-80'''

        import re
        p = re.compile(r'^\d+', re.M)
        for one in  p.findall(content):
            print(one)
        注意:compile 的第二个参数 re.M ，指明了使用多行模式

       -:$ 表示匹配文本的 结尾 位置。

        如果是 单行模式 ，表示匹配 整个文本 的结尾位置。

        如果是 多行模式 ，表示匹配 文本每行 的结尾位置。

        比如，下面的文本中，每行最前面的数字表示水果的编号，最后的数字表示价格

        001-苹果价格-60，
        002-橙子价格-70,
        003-香蕉价格-80,
        如果我们要提取所有的水果编号，用这样的正则表达式 \d+$

        对应代码

        content = '''001-苹果价格-60
        002-橙子价格-70
        003-香蕉价格-80'''

        import re
        p = re.compile(r'\d+$', re.MULTILINE)
        for one in  p.findall(content):
            print(one)
        注意，compile 的第二个参数 re.MULTILINE ，指明了使用多行模式

    11.竖线(|)匹配其中之一:竖线表示 匹配 其中之一(就是或的意思)
        比如:r"黄|橙|绿"就是匹配到里面的黄或橙或绿,即,有就匹配,没有就算了

        特别要注意的是， 竖线在正则表达式的优先级是最低的， 这就意味着，竖线隔开的部分是一个整体

        比如 绿色|橙 表示 要匹配是 绿色 或者 橙 ，

        而不是 绿色 或者 绿橙

    12.括号(())分组:括号称之为 正则表达式的 组选择

        组 就是把 正则表达式 匹配的内容 里面 其中的某些部分 标记为某个组。

        我们可以在 正则表达式中 标记 多个 组

        为什么要有组的概念呢？因为我们往往需要提取已经匹配的 内容里面的 某些部分的信心。

        分组 还可以多次使用。

        比如，我们要从下面的文本中，提取出每个人的 名字 和对应的 手机号

        张三，手机号码15945678901
        李四，手机号码13945677701
        王二，手机号码13845666901
        可以使用这样的正则表达式 ^(.+)，.+(\d{11})

        可以写出如下的代码

        content = '''张三，手机号码15945678901
        李四，手机号码13945677701
        王二，手机号码13845666901'''

        import re
        p = re.compile(r'^(.+)，.+(\d{11})', re.MULTILINE)
        for one in  p.findall(content):
            print(one)

        当有多个分组的时候，我们可以使用 (?P<分组名>...) 这样的格式，给每个分组命名。

        这样做的好处是，更方便后续的代码提取每个分组里面的内容

        比如

        content = '''张三，手机号码15945678901
        李四，手机号码13945677701
        王二，手机号码13845666901'''

        import re
        p = re.compile(r'^(?P<name>.+)，.+(?P<phone>\d{11})', re.MULTILINE)
        for match in  p.finditer(content):
            print(match.group('name'))
            print(match.group('phone'))

    13.让点匹配换行:前面说过, 点 是 不匹配换行符 的，可是有时候，特征 字符串就是跨行的
        <div class="el">
            <p class="t1">
                <span>
                    <a>Python开发工程师</a>
                </span>
            </p>
                <span class="t2">南京</span>
                <span class="t3">1.5-2万/月</span>
        </div>
        <div class="el">
                <p class="t1">
                    <span>
                        <a>java开发工程师</a>
                    </span>
                </p>
                <span class="t2">苏州</span>
                <span class="t3">1.5-2/月</span>
        </div>
        如果你直接使用表达式 class=\"t1\">.*?<a>(.*?)</a> 会发现匹配不上，因为 t1 和 <a> 之间有两个空行。

        这时你需要 点也匹配换行符 ，可以使用 DOTALL 参数

        像这样

        content = '''
        <div class="el">
                <p class="t1">
                    <span>
                        <a>Python开发工程师</a>
                    </span>
                </p>
                <span class="t2">南京</span>
                <span class="t3">1.5-2万/月</span>
        </div>
        <div class="el">
                <p class="t1">
                    <span>
                        <a>java开发工程师</a>
                    </span>
                </p>
                <span class="t2">苏州</span>
                <span class="t3">1.5-2/月</span>
        </div>
        '''

        import re
        p = re.compile(r'class=\"t1\">.*?<a>(.*?)</a>', re.DOTALL)
        for one in  p.findall(content):
            print(one)

    14.切割字符串
        字符串 对象的 split 方法只适用于 简单的字符串分割。 有时，你需要更加灵活的字符串切割。

        比如，我们需要从下面字符串中提取武将的名字。

        names = '关羽; 张飞, 赵云,马超, 黄忠  李逵'
        我们发现这些名字之间， 有的是分号隔开，有的是逗号隔开，有的是空格隔开， 而且分割符号周围还有不定数量的空格

        这时，可以使用正则表达式里面的 split 方法：

        import re

        names = '关羽; 张飞, 赵云,   马超, 黄忠  李逵'

        namelist = re.split(r'[;,\s]\s*', names)
        print(namelist)
        正则表达式 [;,\s]\s* 指定了，分割符为 分号、逗号、空格 里面的任意一种均可，并且 该符号周围可以有不定数量的空格。

    15.字符串替换
        匹配模式替换
            字符串 对象的 replace 方法只适应于 简单的 替换。 有时，你需要更加灵活的字符串替换。

            比如，我们需要在下面这段文本中 所有的 链接中 找到所以 /avxxxxxx/ 这种 以 /av 开头，后面接一串数字， 这种模式的字符串。

            然后，这些字符串全部 替换为 /cn345677/ 。

            names = '''

            下面是这学期要学习的课程：

            <a href='https://www.bilibili.com/video/av66771949/?p=1' target='_blank'>点击这里，边看视频讲解，边学习以下内容</a>
            这节讲的是牛顿第2运动定律

            <a href='https://www.bilibili.com/video/av46349552/?p=125' target='_blank'>点击这里，边看视频讲解，边学习以下内容</a>
            这节讲的是毕达哥拉斯公式

            <a href='https://www.bilibili.com/video/av90571967/?p=33' target='_blank'>点击这里，边看视频讲解，边学习以下内容</a>
            这节讲的是切割磁力线
            '''
            被替换的内容不是固定的，所以没法用 字符串的replace方法。

            这时，可以使用正则表达式里面的 sub 方法：

            import re

            names = '''

            下面是这学期要学习的课程：

            <a href='https://www.bilibili.com/video/av66771949/?p=1' target='_blank'>点击这里，边看视频讲解，边学习以下内容</a>
            这节讲的是牛顿第2运动定律

            <a href='https://www.bilibili.com/video/av46349552/?p=125' target='_blank'>点击这里，边看视频讲解，边学习以下内容</a>
            这节讲的是毕达哥拉斯公式

            <a href='https://www.bilibili.com/video/av90571967/?p=33' target='_blank'>点击这里，边看视频讲解，边学习以下内容</a>
            这节讲的是切割磁力线
            '''

            newStr = re.sub(r'/av\d+?/', '/cn345677/' , names)
            print(newStr)
            sub 方法就是也是替换 字符串， 但是被替换的内容 用 正则表达式来表示 符合特征的所有字符串。

            比如，这里就是第一个参数 /av\d+?/ 这个正则表达式，表示以 /av 开头，后面是一串数字，再以 / 结尾的 这种特征的字符串 ，是需要被替换的。

            第二个参数，这里 是 '/cn345677/' 这个字符串，表示用什么来替换。

            第三个参数是 源字符串。

        指定替换函数
            点击这里，边看视频讲解，边学习以下内容


            刚才的例子中，我们用来替换的是一个固定的字符串 /cn345677/。

            如果，我们要求，替换后的内容 的是原来的数字+6， 比如 /av66771949/ 替换为 /av66771955/ 。

            怎么办？

            这种更加复杂的替换，我们可以把 sub的第2个参数 指定为一个函数 ，该函数的返回值，就是用来替换的字符串。

            如下

            import re

            names = '''

            下面是这学期要学习的课程：

            <a href='https://www.bilibili.com/video/av66771949/?p=1' target='_blank'>点击这里，边看视频讲解，边学习以下内容</a>
            这节讲的是牛顿第2运动定律

            <a href='https://www.bilibili.com/video/av46349552/?p=125' target='_blank'>点击这里，边看视频讲解，边学习以下内容</a>
            这节讲的是毕达哥拉斯公式

            <a href='https://www.bilibili.com/video/av90571967/?p=33' target='_blank'>点击这里，边看视频讲解，边学习以下内容</a>
            这节讲的是切割磁力线
            '''

            # 替换函数，参数是 Match对象
            def subFunc(match):
                # Match对象 的 group(0) 返回的是整个匹配上的字符串，
                src = match.group(0)

                # Match对象 的 group(1) 返回的是第一个group分组的内容
                number = int(match.group(1)) + 6
                dest = f'/av{number}/'

                print(f'{src} 替换为 {dest}')

                # 返回值就是最终替换的字符串
                return dest

            newStr = re.sub(r'/av(\d+?)/', subFunc , names)
            print(newStr)

            获取组内字符串，如下

            match.group(0) # 获取整个匹配字符串
            match.group(1) # 获取第1个组内字符串
            match.group(2) # 获取第2个组内字符串
            Python 3.6 以后的版本 ，写法也可以更加简洁，直接像列表一样使用下标，如下

            match[0]
            match[1]
            match[2]

            上面这个例子中：

            正则表达式 re.sub 函数执行时， 每发现一个 匹配的子串， 就会：

            实例化一个 match对象

            这个match 对象包含了这次匹配的信息， 比如：整个字符串是什么，匹配部分字符串是什么，里面的各个group分组 字符串是什么

            调用执行 sub函数的第2个参数对象，也就是调用回调函数subFunc

            并且把刚才产生的 match 对象作为参数传递给 subFunc